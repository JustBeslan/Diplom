import librosaimport numpy as npimport mathimport sklearnfrom librosa import displayfrom matplotlib import pyplot as pltfrom sklearn.mixture import GaussianMixture as GMMdef SplitAudio(data, sr, window_ms, margin_ms):    print("SplitAudio...")    partsAudio = []    stepWindow = int((sr / 1000) * window_ms)    stepMargin = int((sr / 1000) * margin_ms)    count_step = math.ceil(len(data) / stepMargin)    for i in range(0, len(data), stepMargin):        partAudio = np.array(data[i:i + stepWindow])        if len(partAudio) == stepWindow:            partsAudio.append(partAudio)    return partsAudiodef toMel(f):    return 1127 * np.log(1 + f / 700)def toBark(f):    return 8.96 * np.log(0.978 + 5 * np.log(0.994 + pow((f + 75.4) / 2173, 1.347)))def getFilteresFFT(data):    onePart = data    # onePart = np.array([onePart[i] - 0.9*onePart[i-1] for i in range(1, len(onePart))])    # onePart = np.array([onePart[i] * (0.53836 - 0.46164 * np.cos(2 * np.pi * i / (len(onePart - 1)))) for i in range(len(onePart))])    FFT_OnePart = np.fft.fft(onePart)    AbsFFT_OnePart = np.abs(FFT_OnePart)    # windowKaiser = np.kaiser(len(onePart), 14)    # AbsFFT_OnePart = np.array([AbsFFT_OnePart[i] * windowKaiser[i] for i in range(len(AbsFFT_OnePart))])    return AbsFFT_OnePartdef skd(v1, v2):    return np.sqrt(np.sum([(v1[i] - v2[i]) ** 2 for i in range(len(v1))]) / np.sum([e ** 2 for e in v1]))def euclidDist(v1, v2):    return np.sqrt(np.sum([(v1[i] - v2[i]) ** 2 for i in range(len(v1))]))def getParameters(data, sr):    stepWindow = len(data)    partData = data    mu = np.sum(partData) / stepWindow    sigma = np.sqrt(np.sum([(partData[i] - mu) ** 2 for i in range(stepWindow)]) / stepWindow)    data = [data[i] - 0.95 * data[i - 1] for i in range(1, len(data))]    return data, mu, sigmapath = 'C:/Users/Ibrag/Desktop/Diplom/Test5/Audio/'name = 'FilteredAudiotest5.wav'time_ms = 100time_s = time_ms / 1000start = 7000data, sr = librosa.load(path + name, duration=120, offset=60, sr=8000)step = time_ms / 1000start = start / 1000onePart = data[sr * int(start):int(sr * (start + step))]onePartAbsHZ = getFilteresFFT(onePart)MFCC_onePart = np.array(librosa.feature.mfcc(onePart, sr, n_mfcc=16)).flatten()mels = np.array([toMel(onePartAbsHZ[i]) for i in range(len(onePartAbsHZ))])minMel = np.min(mels)maxMel = np.max(mels)barks = np.array([toBark(onePartAbsHZ[i]) for i in range(len(onePartAbsHZ))])minBark = np.min(barks)maxBark = np.max(barks)partsAudio = SplitAudio(data, sr, time_ms, time_ms)res = []mfccs = []melsAll = []barksAll = []skdAll = []hzAll = []for part in partsAudio:    MFCC_Part = np.array(librosa.feature.mfcc(part, sr, n_mfcc=16)).flatten()    mfccs.append(np.array(MFCC_Part).flatten())    partAbsHZ = getFilteresFFT(part)    hzAll.append(partAbsHZ)    melsP = len([e for e in partAbsHZ if minMel <= toMel(e) <= maxMel])    melsAll.append(melsP)    barksP = len([e for e in partAbsHZ if minBark <= toBark(e) <= maxBark])    barksAll.append(barksP)    # skdP = skd(part, onePart)    # skdAll.append(skdP)    if melsP >= len(part) // 2 and barksP >= len(part) // 2:        # data, mu, sigma = getParameters(part, sr)        # A = [d for d in data if np.abs(d - mu)/sigma >= 0.0001]        # if len(A) >= len(data):        res.append(part)res0 = np.array(res).flatten()librosa.output.write_wav(path + "Presenter_" + name, res0, sr)plt.plot(np.array(hzAll).flatten())plt.show()
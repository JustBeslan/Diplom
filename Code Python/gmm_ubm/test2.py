import osimport pickleimport librosaimport numpy as npimport mathimport sklearnfrom librosa import displayfrom matplotlib import pyplot as pltfrom scipy.io.wavfile import readfrom sklearn import preprocessingfrom sklearn.mixture import GaussianMixture as GMMimport python_speech_features as mfccdef SplitAudio(data, sr, window_ms, margin_ms):    print("SplitAudio...")    partsAudio = []    stepWindow = int((sr / 1000) * window_ms)    stepMargin = int((sr / 1000) * margin_ms)    count_step = math.ceil(len(data) / stepMargin)    for i in range(0, len(data), stepMargin):        partAudio = np.array(data[i:i + stepWindow])        if len(partAudio) == stepWindow:            partsAudio.append(partAudio)    return partsAudiodef toMel(f):    return 1127 * np.log(1 + f / 700)def toBark(f):    return 8.96 * np.log(0.978 + 5 * np.log(0.994 + pow((f + 75.4) / 2173, 1.347)))def getFilteresFFT(data):    onePart = data    # onePart = np.array([onePart[i] - 0.9*onePart[i-1] for i in range(1, len(onePart))])    # onePart = np.array([onePart[i] * (0.53836 - 0.46164 * np.cos(2 * np.pi * i / (len(onePart - 1)))) for i in range(len(onePart))])    FFT_OnePart = np.fft.fft(onePart)    AbsFFT_OnePart = np.abs(FFT_OnePart)    # windowKaiser = np.kaiser(len(onePart), 14)    # AbsFFT_OnePart = np.array([AbsFFT_OnePart[i] * windowKaiser[i] for i in range(len(AbsFFT_OnePart))])    return AbsFFT_OnePartdef skd(v1, v2):    return np.sqrt(np.sum([(v1[i] - v2[i]) ** 2 for i in range(len(v1))]) / np.sum([e ** 2 for e in v1]))def euclidDist(v1, v2):    return np.sqrt(np.sum([(v1[i] - v2[i]) ** 2 for i in range(len(v1))]))path = 'C:/Users/Ibrag/Desktop/Diplom/Test5/Audio/'name = 'FilteredAudiotest5.wav'time_ms = 100time_s = time_ms / 1000start = 7000data, sr = librosa.load(path + name, duration=120, offset=60, sr=8000)step = time_ms / 1000start = start / 1000onePart = data[sr * int(start):int(sr * (start + step))]# ------------------------------------------------------------------------def get_MFCC(sr, audio):    features = mfcc.mfcc(audio, sr, 0.025, 0.01, 13, appendEnergy=False)    feat = np.asarray(())    for i in range(features.shape[0]):        temp = features[i, :]        if np.isnan(np.min(temp)):            continue        else:            if feat.size == 0:                feat = temp            else:                feat = np.vstack((feat, temp))    features = feat    features = preprocessing.scale(features)    return featuresmodelpath = "C:/Users/Ibrag/Desktop/Diplom/Datasets/Dataset1/pygender/"gmm_files = [os.path.join(modelpath, fname) for fname in os.listdir(modelpath) if fname.endswith('.gmm')]models = [pickle.load(open(fname, 'rb')) for fname in gmm_files]genders = [fname.split("/")[-1].split(".gmm")[0] for fname in gmm_files]files = path + namesr, audio = read(files)features = get_MFCC(sr, audio)scores = Nonelog_likelihood = np.zeros(len(models))for i in range(len(models)):    gmm = models[i]  # checking with each model one by one    scores = np.array(gmm.score(features))    log_likelihood[i] = scores.sum()winner = np.argmax(log_likelihood)print("\tdetected as - ", genders[winner], "\n\tscores:female ", log_likelihood[0], ",male ", log_likelihood[1], "\n")# ------------------------------------------------------------------------onePartAbsHZ = getFilteresFFT(onePart)MFCC_onePart = np.array(librosa.feature.mfcc(onePart, sr, n_mfcc=16)).flatten()mels = np.array([toMel(onePartAbsHZ[i]) for i in range(len(onePartAbsHZ))])minMel = np.min(mels)maxMel = np.max(mels)barks = np.array([toBark(onePartAbsHZ[i]) for i in range(len(onePartAbsHZ))])minBark = np.min(barks)maxBark = np.max(barks)partsAudio = SplitAudio(data, sr, time_ms, time_ms)res = []mfccs = []melsAll = []barksAll = []skdAll = []hzAll = []for part in partsAudio:    MFCC_Part = np.array(librosa.feature.mfcc(part, sr, n_mfcc=16)).flatten()    mfccs.append(np.array(MFCC_Part).flatten())    partAbsHZ = getFilteresFFT(part)    hzAll.append(partAbsHZ)    melsP = len([e for e in partAbsHZ if minMel <= toMel(e) <= maxMel])    melsAll.append(melsP)    barksP = len([e for e in partAbsHZ if minBark <= toBark(e) <= maxBark])    barksAll.append(barksP)    # skdP = skd(part, onePart)    # skdAll.append(skdP)    if melsP >= len(part) // 2 and barksP >= len(part) // 2:        res.append(part)res0 = np.array(res).flatten()librosa.output.write_wav(path + "Presenter_" + name, res0, sr)plt.plot(np.array(hzAll).flatten())plt.show()